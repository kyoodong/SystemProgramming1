/*
 * 화일명 : my_assembler_00000000.c 
 * 설  명 : 이 프로그램은 SIC/XE 머신을 위한 간단한 Assembler 프로그램의 메인루틴으로,
 * 입력된 파일의 코드 중, 명령어에 해당하는 OPCODE를 찾아 출력한다.
 * 파일 내에서 사용되는 문자열 "00000000"에는 자신의 학번을 기입한다.
 */

/*
 *
 * 프로그램의 헤더를 정의한다. 
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>

#include "my_assembler_20162489.h"

/* ----------------------------------------------------------------------------------
 * 설명 : 사용자로 부터 어셈블리 파일을 받아서 명령어의 OPCODE를 찾아 출력한다.
 * 매계 : 실행 파일, 어셈블리 파일 
 * 반환 : 성공 = 0, 실패 = < 0 
 * 주의 : 현재 어셈블리 프로그램의 리스트 파일을 생성하는 루틴은 만들지 않았다. 
 *		   또한 중간파일을 생성하지 않는다. 
 * ----------------------------------------------------------------------------------
 */
int main(int args, char *arg[]) 
{
	if(init_my_assembler()< 0)
	{
		printf("init_my_assembler: 프로그램 초기화에 실패 했습니다.\n"); 
		return -1 ; 
	}

	if(assem_pass1() < 0 ){
		printf("assem_pass1: 패스1 과정에서 실패하였습니다.  \n") ; 
		return -1 ; 
	}

	make_symtab_output("symtab_20162489");
	if (assem_pass2() < 0) {
		printf(" assem_pass2: 패스2 과정에서 실패하였습니다.  \n");
		return -1;
	}

	make_objectcode_output("output_20162489");
	return 0;
}

/* ----------------------------------------------------------------------------------
 * 설명 : 프로그램 초기화를 위한 자료구조 생성 및 파일을 읽는 함수이다. 
 * 매계 : 없음
 * 반환 : 정상종료 = 0 , 에러 발생 = -1
 * 주의 : 각각의 명령어 테이블을 내부에 선언하지 않고 관리를 용이하게 하기 
 *		   위해서 파일 단위로 관리하여 프로그램 초기화를 통해 정보를 읽어 올 수 있도록
 *		   구현하였다. 
 * ----------------------------------------------------------------------------------
 */
int init_my_assembler(void)
{
	int result ; 

	if ((result = init_directive_file("directive.data")) < 0)
		return -1;
	if((result = init_inst_file("inst.data")) < 0 )
		return -1 ;
	if((result = init_input_file("input.txt")) < 0 )
		return -1 ; 
	return result ; 
}

/* ----------------------------------------------------------------------------------
 * 설명 : 머신을 위한 기계 코드목록 파일을 읽어 기계어 목록 테이블(inst_table)을 
 *        생성하는 함수이다. 
 * 매계 : 기계어 목록 파일
 * 반환 : 정상종료 = 0 , 에러 < 0 
 * 주의 : 기계어 목록파일 형식은 자유롭게 구현한다. 예시는 다음과 같다.
 *	
 *	===============================================================================
 *		   | 이름 | 형식 | 기계어 코드 | 오퍼랜드의 갯수 | NULL|
 *	===============================================================================	   
 *		
 * ----------------------------------------------------------------------------------
 */
int init_inst_file(char *inst_file)
{
	FILE * file = fopen(inst_file, "r");
	if (file == NULL) {
		fclose(file);
		return -1;
	}

	while (!feof(file)) {
		inst* p_inst = calloc(sizeof(inst), 1);

		// 형식에 맞춰서 읽어들임
		if (fscanf(file, "%s %d %2hhx %d", p_inst->name, &p_inst->format, &p_inst->opcode, &p_inst->operandCount) != 4) {
			// 형식에 맞지 않은 경우 지금까지 읽었던 데이터를 모두 메모리 해제
			for (int i = 0; i < inst_index; i++) {
				free(inst_table[i]);
			}
			inst_index = 0;
			fclose(file);
			return -2;
		}
		inst_table[inst_index++] = p_inst;
	}
	fclose(file);
	return 0;
}

/* ----------------------------------------------------------------------------------
 * 설명 : 어셈블러 지시어 목록 파일을 읽어 지시어 목록 테이블(directive_table)을 생성하는 함수이다.
 * 매계 : 지시어 목록 파일
 * 반환 : 정상종료 = 0 , 에러 < 0
 */
int init_directive_file(char *directive_file)
{
	FILE * file = fopen(directive_file, "r");
	if (file == NULL) {
		fclose(file);
		return -1;
	}

	while (!feof(file)) {
		directive* p_directive = calloc(sizeof(directive), 1);

		// 형식에 맞춰서 읽어들임
		if (fscanf(file, "%s %d", p_directive->name, &p_directive->operandCount) != 2) {
			// 형식에 맞지 않은 경우 지금까지 읽었던 데이터를 모두 메모리 해제
			for (int i = 0; i < directive_index; i++) {
				free(directive_table[i]);
			}
			directive_index = 0;
			fclose(file);
			return -2;
		}
		directive_table[directive_index++] = p_directive;
	}
	fclose(file);
	return 0;
}

/* ----------------------------------------------------------------------------------
 * 설명 : 어셈블리 할 소스코드를 읽어 소스코드 테이블(input_data)를 생성하는 함수이다. 
 * 매계 : 어셈블리할 소스파일명
 * 반환 : 정상종료 = 0 , 에러 < 0  
 * 주의 : 라인단위로 저장한다.
 *		
 * ----------------------------------------------------------------------------------
 */
int init_input_file(char *input_file)
{
	FILE * file = fopen(input_file, "r");
	if (file == NULL) {
		fclose(file);
		return -1;
	}
	line_num = 0;

	while (!feof(file)) {
		char str[100] = { 0 };
		if (fscanf(file, "%[^\n]", str) == -1)
			continue;
		fgetc(file);

		char* d_str = calloc(sizeof(char) * strlen(str), 1);
		strcpy(d_str, str);
		input_data[line_num++] = d_str;
	}
	
	fclose(file);
	return 0;
}

/* ----------------------------------------------------------------------------------
 * 설명 : 소스 코드를 읽어와 토큰단위로 분석하고 토큰 테이블을 작성하는 함수이다. 
 *        패스 1로 부터 호출된다. 
 * 매계 : 파싱을 원하는 문자열  
 * 반환 : 정상종료 = 0 , 에러 < 0 
 * 주의 : my_assembler 프로그램에서는 라인단위로 토큰 및 오브젝트 관리를 하고 있다. 
 * ----------------------------------------------------------------------------------
 */
int token_parsing(char *str) 
{
	token* newToken = calloc(sizeof(token), 1);

	// 레이블 존재 유무 판단
	if (str[0] != '\t') {
		sscanf(str, "%s", newToken->label);

		// 심볼 추가
		symbol newSymbol;
		strcpy()
		strcpy(newSymbol.symbol, newToken->label);
		newSymbol.addr = locctr;
		sym_table[symbolIndex++] = newSymbol;

		// 주석문이면 무시
		if (newToken->label[0] == '.') {
			free(newToken);
			return 0;
		}
	}

	// 명령어 여부 검사
	newToken->instIndex = search_opcode(str, newToken->operator);
	if (newToken->instIndex >= 0) {
		// 명령어가 맞으므로 지시어가 아님을 표현하기 위해 directiveIndex를 -1로 초기화
		newToken->directiveIndex = -1;

		// 피연산자를 입력받는 연산자인지 체크
		if (inst_table[newToken->instIndex]->operandCount > 0) {
			if (read_operand(str, newToken->operand[0]) == -1)
				return -1;

			// 피연산자를 입력받고, ','(쉼표)로 구분하여 여러개의 피연산자가 지정된 경우
			// 이들 각각을 operand[index]에 나누어 저장
			newToken->operandCount = 1;
			while (split(newToken->operand[newToken->operandCount - 1], newToken->operand[newToken->operandCount], ',') != -1)
				newToken->operandCount++;
		}

		// 1, 2형식
		if (inst_table[newToken->instIndex]->format < 3)
			locctr += inst_table[newToken->instIndex]->format;

		// 4형식
		else if (newToken->operator[0] == '+')
			locctr += 4;

		// 3형식
		else
			locctr += 3;
	}

	// 명령어가 아님
	else {
		// 지시어 여부 검사
		int directive_index = search_directive(str);
		if (directive_index >= 0) {
			// 지시어가 맞으므로 명령어가 아님을 표현하기 위해 instIndex를 -1로 초기화
			newToken->instIndex = -1;
			strcpy(newToken->operator, directive_table[directive_index]->name);

			// 피연산자를 입력받는 지시어인지 체크
			if (directive_table[directive_index]->operandCount > 0) {
				if (read_operand(str, newToken->operand[0]) == -1)
					return -1;

				// 피연산자를 입력받고, ','(쉼표)로 구분하여 여러개의 피연산자가 지정된 경우
				// 이들 각각을 operand[index]에 나누어 저장
				newToken->operandCount = 1;
				while (split(newToken->operand[newToken->operandCount - 1], newToken->operand[newToken->operandCount], ',') != -1)
					newToken->operandCount++;
			}
		}
		// 명령어도, 지시어도 아닌 상황
		else {
			// TODO: 알 수 없는 키워드 에러 처리
		}
	}
	token_table[token_line++] = newToken;
	return 0;
}

/*
* 설명 : 문자열을 특정 문자(토큰)를 기준으로 자르는 함수이다.
* 매개 : srcStr = 자를 문자열. 함수 실행 후 토큰을 기준으로 좌측에 위치한 문자열이 저장된다.
*		dstStr = 함수 실행 후 토큰을 기준으로 우측에 위치한 문자열이 저장된다.
*		token = 문자열을 자르는 기준이 되는 문자
* 반환 : ( -1 ) = 문자열 내에 토큰 문자가 없을때
*		( 0 ) = 성공적으로 잘라내었을 때
*/
int split(char* srcStr, char* dstStr, char token) {
	int length = strlen(srcStr);
	int i;
	for (i = 0; srcStr[i] != token && srcStr[i] != '\0'; i++);

	if (srcStr[i] == '\0')
		return -1;

	srcStr[i] = '\0';
	int j;
	for (j = 0; i + 1 + j < length && srcStr[i + 1 + j] != '\0'; j++) {
		dstStr[j] = srcStr[i + 1 + j];
	}
	dstStr[j] = '\0';
	return 0;
}

/*
* 설명 : 피연산자를 읽어들이는 함수이다.
* 매개 : str = 토큰(\n)으로 구분된 문자열, str_for_save = 명령어가 저장될 문자열
* 반환 : ( -1 ) = 오류 발생
*		( 0 ) = 정상종료
*/
int read_operand(const char* str, char* str_for_save) {
	int skip_index = skip_past_blank(str);
	if (skip_index == -1)
		return -1;

	str += skip_index;

	skip_index = skip_past_blank(str);
	if (skip_index == -1)
		return -1;

	str += skip_index;
	sscanf(str, "%s", str_for_save);
	return 0;
}

/*
* 설명 : 문자열 왼쪽 맨 끝에 있는 \t 문자를 모두 건너뛰기 위한 함수이다.
* 매개 : \t 건너뛰기를 원하는 문자열
* 반환 : 정상종료 = \t가 아닌 문자가 처음으로 나오는 인덱스
*		\t가 없는 경우 = ( -1 )
*/
int skip_past_blank(char* str) {
	int count = 0;
	while (str[count] != '\t') {
		if (str[count] == '\n' || str[count] == '\0')
			return -1;

		count++;
	}
	return count + 1;
}

/*
* 설명 : 두 문자열이 같은지 비교하는 함수이다.
* 매개 : 비교하고 싶은 문자열
* 반환 : 같음 = 1, 다름 = 0
*/
int is_equal_string(const char* str1, const char* str2) {
	int length = strlen(str1);
	if (length != strlen(str2))
		return 0;

	for (int i = 0; i < length; i++) {
		if (str1[i] != str2[i])
			return 0;
	}
	return 1;
}

/* ----------------------------------------------------------------------------------
 * 설명 : 입력 문자열이 기계어 코드인지를 검사하는 함수이다. 
 * 매개 : str = 토큰 단위로 구분된 문자열, op = 명렁어 코드를 저장할 문자열(NULL 가능)
 * 반환 : 정상종료 = 기계어 테이블 인덱스, 에러 < 0 
 * 주의 : 
 *		
 * ----------------------------------------------------------------------------------
 */
int search_opcode(char *str, char* op) 
{
	if (op == NULL) {
		char new_op[20];
		op = new_op;
	}

	int skipIndex = skip_past_blank(str);
	if (skipIndex == -1)
		return -1;

	str += skipIndex;

	sscanf(str, "%s", op);
	int format = 0;
	if (str[0] == '+') {
		format = 4;
		op++;
	}

	for (int i = 0; i < inst_index; i++) {
		if (is_equal_string(inst_table[i]->name, op)) {
			if (format == 4) {
				if (inst_table[i]->format == 3) {
					return i;
				}
			}
			else {
				return i;
			}
		}
	}

	// 찾지 못함
	return -1;
}

/* ----------------------------------------------------------------------------------
 * 설명 : 입력 문자열이 어셈블러 지시어인지를 검사하는 함수이다.
 * 매계 : 토큰 단위로 구분된 문자열
 * 반환 : 정상종료 = 지시어 테이블 인덱스, 지시어 아님 = -1, 에러 < -1
 * 주의 :
 *
 * ----------------------------------------------------------------------------------
 */
int search_directive(char *str)
{
	// 지시어 위치까지 포인터 이동
	int skipIndex = skip_past_blank(str);
	if (skipIndex == -1)
		return -1;
	str += skipIndex;

	// 지시어 여부 체크
	char directive[20];
	sscanf(str, "%s", directive);
	for (int i = 0; i < directive_index; i++) {
		if (is_equal_string(directive_table[i]->name, directive)) {
			return i;
		}
	}
	return -1;
}

/* ----------------------------------------------------------------------------------
* 설명 : 어셈블리 코드를 위한 패스1과정을 수행하는 함수이다.
*		   패스1에서는..
*		   1. 프로그램 소스를 스캔하여 해당하는 토큰단위로 분리하여 프로그램 라인별 토큰
*		   테이블을 생성한다.
*
* 매계 : 없음
* 반환 : 정상 종료 = 0 , 에러 = < 0
* 주의 : 현재 초기 버전에서는 에러에 대한 검사를 하지 않고 넘어간 상태이다.
*	  따라서 에러에 대한 검사 루틴을 추가해야 한다.
*
* -----------------------------------------------------------------------------------
*/
static int assem_pass1(void)
{
	/* input_data의 문자열을 한줄씩 입력 받아서
	 * token_parsing()을 호출하여 token_unit에 저장
	 */
	for (int i = 0; i < line_num; i++) {
		if (token_parsing(input_data[i]) < 0)
			return -1;
	}
	return 0;
}


/* ----------------------------------------------------------------------------------
* 설명 : 입력된 문자열의 이름을 가진 파일에 프로그램의 결과를 저장하는 함수이다.
*        여기서 출력되는 내용은 명령어 옆에 OPCODE가 기록된 표(과제 4번) 이다.
* 매계 : 생성할 오브젝트 파일명
* 반환 : 없음
* 주의 : 만약 인자로 NULL값이 들어온다면 프로그램의 결과를 표준출력으로 보내어
*        화면에 출력해준다.
*        또한 과제 4번에서만 쓰이는 함수이므로 이후의 프로젝트에서는 사용되지 않는다.
* -----------------------------------------------------------------------------------
*/
void make_opcode_output(char *file_name)
{
	// 표준 출력
	if (file_name == NULL) {
		for (int i = 0; i < token_line; i++) {
			printf("%s\t%s\t%s", token_table[i]->label, token_table[i]->operator, token_table[i]->operand[0]);
			for (int j = 1; j < token_table[i]->operandCount; j++)
				printf(",%s", token_table[i]->operand[j]);
			if (token_table[i]->instIndex >= 0)
				printf("\t%02X", inst_table[token_table[i]->instIndex]->opcode);
			printf("\n");
		}
		return;
	}

	// 파일 출력
	FILE* file = fopen(file_name, "w");
	if (file == NULL) {
		fclose(file);
		return;
	}

	for (int i = 0; i < token_line; i++) {
		fprintf(file, "%s\t%s\t%s", token_table[i]->label, token_table[i]->operator, token_table[i]->operand[0]);
		for (int j = 1; j < token_table[i]->operandCount; j++)
			fprintf(file, ",%s", token_table[i]->operand[j]);
		if (token_table[i]->instIndex >= 0)
			fprintf(file, "\t%02X", inst_table[token_table[i]->instIndex]->opcode);
		fprintf(file, "\n");
	}
	fclose(file);
}

/* --------------------------------------------------------------------------------*
* ------------------------- 추후 프로젝트에서 사용할 함수 --------------------------*
* --------------------------------------------------------------------------------*/

/* ----------------------------------------------------------------------------------
* 설명 : 입력된 문자열의 이름을 가진 파일에 프로그램의 결과를 저장하는 함수이다.
*        여기서 출력되는 내용은 SYMBOL별 주소값이 저장된 TABLE이다.
* 매계 : 생성할 오브젝트 파일명
* 반환 : 없음
* 주의 : 만약 인자로 NULL값이 들어온다면 프로그램의 결과를 표준출력으로 보내어
*        화면에 출력해준다.
*
* -----------------------------------------------------------------------------------
*/
void make_symtab_output(char *file_name)
{
	// 표준 입출력
	if (file_name == NULL) {

		return;
	}

	// 파일 입출력
	FILE* file = fopen(file_name, "w");
	if (file == NULL) {
		printf("%s 파일 생성 에러\n", file_name);
		return;
	}

	fclose(file);
}

/* ----------------------------------------------------------------------------------
* 설명 : 어셈블리 코드를 기계어 코드로 바꾸기 위한 패스2 과정을 수행하는 함수이다.
*		   패스 2에서는 프로그램을 기계어로 바꾸는 작업은 라인 단위로 수행된다.
*		   다음과 같은 작업이 수행되어 진다.
*		   1. 실제로 해당 어셈블리 명령어를 기계어로 바꾸는 작업을 수행한다.
* 매계 : 없음
* 반환 : 정상종료 = 0, 에러발생 = < 0
* 주의 :
* -----------------------------------------------------------------------------------
*/
static int assem_pass2(void)
{

	/* add your code here */

}

/* ----------------------------------------------------------------------------------
* 설명 : 입력된 문자열의 이름을 가진 파일에 프로그램의 결과를 저장하는 함수이다.
*        여기서 출력되는 내용은 object code (프로젝트 1번) 이다.
* 매계 : 생성할 오브젝트 파일명
* 반환 : 없음
* 주의 : 만약 인자로 NULL값이 들어온다면 프로그램의 결과를 표준출력으로 보내어
*        화면에 출력해준다.
*
* -----------------------------------------------------------------------------------
*/
void make_objectcode_output(char *file_name)
{
	/* add your code here */

}
